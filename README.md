# BHS2025_LODTestTask
Test task for BHS for the position "LOD module programmer"

# Задание 1

## Задание 1.1

Выполнено в полном объеме.

## Задание 1.2

Интерфейсы в C# (и в других объектно-ориентированных языках) — это мощный инструмент для проектирования гибких и расширяемых систем. Они позволяют определять общий вид наюора полей и классов, которые должны реализовывать классы, без привязки к конкретной реализации. Более того, они дают доступ к мокингу и мультинаследованию (что абстрактные классы сделать не могут). 

## Задание 1.3

Добавлены мьютексы (не совсем правда, там lock а не mutex, но в контексте одно и тоже), поэтому можно в мультитреды и иметь гарант, что операция выполнется корректно.

## Задание 2

LOD — это крутая штука, которая помогает играм работать плавно и выглядеть хорошо, даже если на экране куча объектов.
На самом базовом уровне она работает как переключатель: в зависимости от евклидового расстояния, мы меняем lod0 - lod1 - lod2 и тп.
Если рассматривать более детально, то дальше идут алгоритмы, как редуктировать полигоны (можно использовать заранее подготовленные модели с меньшим числом полгинов, так и в рантайме менять их число). Есть алгосы: Алгоритм Дугласа-Пекера и Алгоритм Quadric Error Metrics. Чтобы резко модели не менялись используется линейная интерполяция, чтобы переход был плавным и не заметным. 

![image](https://github.com/user-attachments/assets/afdf3b11-92fb-4afe-ad07-7d0a8b64d48e)

И так настроили LOD. Как видно, чем больше индекс лода, тем меньше количество полигонов.

![image](https://github.com/user-attachments/assets/bb3b9eb9-ebce-49fa-9914-2e3a6e2613f8)

Про видимость вне поля камеры - это Occlusion Culling. Occlusion Culling это функция, отключающая рендеринг тех объектов, которые в данные момент не видит камера (они закрыты другими объектами). В компьютерной 3D графике это не происходит автоматически. Чаще всего сначала отрисовываются объекты, расположенные дальше от камеры и уже поверх них отрисовываются ближние к камере объекты (это называется “overdraw”). Occlusion Culling отличается от Frustum Culling. Frustum Culling отключает только рендеринг объектов, не попадающих в область обзора камеры, не трогая при этом скрытые по overdraw объекты.

Occlusion сulling, используя виртуальную камеру, проходит по сцене для построения иерархии потенциально видимых наборов объектов. Эти данные используются в рантайме каждой камерой для определения того что она видит, и что нет. Опираясь на полученную информацию, Unity обеспечивает рендеринг только видимых объектов. Это уменьшает количество draw calls и увеличивает производительность игры.

Данные для occlusion culling состоят из ячеек. Каждая ячейка - частичка сцены. Ячейки образуют бинарное дерево. Occlusion Culling использует два дерева. Первое View Cells(для статичных объектов), второе Target Cells(для движущихся объектов). View Cells содержит список индексов, который определяет видимость статичных объектов с более высокой точностью.

Об этом важно помнить при создании объектов, потому что нужен хороший баланс между размерами объектов и ячеек. В идеале, у вас не должно быть ячеек, которые очень малы по сравнению с объектами. И в то же время, у вас не должно быть объектов, охватывающих большое количество ячеек.

Видео демонстрация:

![Unity_HZkkiM3aBF](https://github.com/user-attachments/assets/a5b62147-c557-418e-9047-0f592f6ffc96)
